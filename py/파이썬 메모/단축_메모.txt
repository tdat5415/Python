조건부 표현식(conditional expression)
변수 = 값 if 조건문 else 값
ex) y = x if x == 10 else 0


for i in range(1, 101):
    print('Fizz' * (i % 3 == 0) + 'Buzz' * (i % 5 == 0) or i)


print(a or b)
a가 False(0)면 b 출력
# a 에 조건문넣어서 활용

print(a and b)
a가 True(not 0)면 b 출력
# 이런식으로는 안쓰일듯


a,b,c = 1,2,3
이것이 가능한 이유는 
1,2,3은 튜플. 즉, (1,2,3)을 뜻하며
따라서 튜플 언패킹(tuple unpacking)이기때문
(튜플의 요소를 변수 여러 개에 할당하는 것)


a = [1,2,3]
a[len(a):] = [10] 과
a.append(10) 은 같다.



a = [1,2,3]
a[len(a):] = [10,20] 과
a.extend([10,20]) 은 같다.


a가 리스트면 
a는 리스트 전체를 뜻하지만
a[:]는 요소 전체를 뜻한다.


len으로 2차원 리스트 a의 크기를 구하면 리스트 안에 들어있는 모든 요소의 개수가 아니라 안쪽 리스트의 개수(세로 크기)가 나온다는 점입니다.


시퀀스 객체에 인덱스 증가폭을 지정하여 요소를 할당할 때는 슬라이스 범위의 요소 개수와 할당할 요소 개수가 정확히 일치해야 한다.(언패킹)


비트연산
&는 and게이트
|는 or게이트
^는 xor게이트


변수값 서로 바꾸기
x, y = y, x 
(튜플의 언패킹)


if 1<a<2:
파이썬은 이것이 가능하다.


메서드체이닝(method chaining)
메서드를 줄줄이 연결한다
>>> 'python'.rjust(10).upper()
'    PYTHON'
참고로 메서드들이 처리한 결과를 반환해야한다.


raw문자열 사용하기
>>> print(r'1\n2\n3\n')
1\n2\n3\n
그대로나온다


리스트에 *를 붙이는 방법은 리스트 언패킹이라고 한다


def one_two():
	return 1, 2  # return (1, 2)와 같음


리스트(튜플) 앞에 *를 붙이면 언패킹(unpacking)이 된다.


가변 인수 함수는 매개변수 앞에 *를 붙여서 만듭니다.
def 함수이름(*매개변수):


함수를 변수 또는 리스트에 넣어서 호출할 수 있다.
x =hello()
x()
y =[hello, hello]
y[1]()
이런식으로


함수를 둘러싼 환경(지역변수, 코드 등)을 계속 유지하다가, 함수를 호출할 때 다시 꺼내서 사용하는 함수를 클로저(closure)라고 합니다.
클로저를 사용하면 프로그램의 흐름을 변수에 저장할 수 있습니다. 즉, 클로저는 지역변수와 코드를 묶어서 사용하고 싶을 때 활용합니다. 또한 클로저에 속한 지역변수는 바깥에서 직접 접근할 수 없으므로 데이터를 숨기고 싶을 때 활용합니다.